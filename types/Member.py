try:
    from Products.CMFCore.interfaces.portal_memberdata import MemberData as IMemberData
    memberdata_interface = 1
except:
    memberdata_interface = 0

import types
import AccessControl.User
import copy
import urllib

from Products.CMFMember import MemberPermissions
from Products.CMFMember.MemberPermissions import VIEW_PUBLIC_PERMISSION, EDIT_ID_PERMISSION, \
    EDIT_REGISTRATION_PERMISSION, VIEW_OTHER_PERMISSION, EDIT_OTHER_PERMISSION, \
    VIEW_SECURITY_PERMISSION, EDIT_PASSWORD_PERMISSION, EDIT_SECURITY_PERMISSION, \
    MAIL_PASSWORD_PERMISSION, ADD_PERMISSION

from AccessControl import ClassSecurityInfo, ModuleSecurityInfo, Owned
from Acquisition import aq_inner, aq_parent, aq_base, aq_chain, aq_get
from Products import CMFCore
from Products.CMFCore.utils import getToolByName, _limitGrantedRoles, _verifyActionPermissions
from Products.CMFCore.Expression import createExprContext
from Products.Archetypes import registerType
from Products.Archetypes.BaseContent import BaseContent
from Products.Archetypes.interfaces.base import IBaseContent
from Products.Archetypes.ExtensibleMetadata import ExtensibleMetadata
from Products.Archetypes.Field       import *
from Products.Archetypes.Widget      import *
from Products.Archetypes.Schema import Schemata, FieldList, MetadataFieldList

from Products.Archetypes.debug import log
from DateTime import DateTime
from Products.CMFMember import RegistrationTool
import copy
import random
from Products.CMFMember.Extensions.Workflow import triggerAutomaticTransitions

from Products.CMFMember.VariableSchemaSupport import VariableSchemaSupport

# generate the addMember method ourselves so we can do some extra initialization
security = ModuleSecurityInfo('Products.CMFMember.types.Member')
security.declareProtected(ADD_PERMISSION, 'addMember')
def addMember(self, id, **kwargs):
    o = Member(id)
    self._setObject(id, o)
    o = getattr(self, id)
    o.initializeArchetype(**kwargs)
    o.getUser()
    o._setPassword(o._generatePassword())


def modify_fti(fti):
    # fix up the factory type information generated by archetypes
    fti['global_allow'] = 0  # only allow Members to be added where explicitly allowed


def logException():
    """Dump an exception to the log"""
    import traceback
    import sys
    from zLOG import LOG, INFO, WARNING

    sys.stdout.write('\n'.join(traceback.format_exception(*sys.exc_info())))
    
    s = sys.exc_info()[:2]  # don't assign the traceback to s (otherwise will generate a circular reference)
    if s[0] == None:
        summary = 'None'
    else:
        if type(s[0]) == type(''):
            summary = s[0]
        else:
            summary = str(s[1])

    LOG('CMFMember Debug', WARNING,
        summary,
        '\n'.join(traceback.format_exception(*sys.exc_info())))


id_schema = FieldList((
    StringField('id',
                accessor='getId',
                mutator='setId',
                mode='rw',
                read_permission=VIEW_PUBLIC_PERMISSION,
                write_permission=EDIT_ID_PERMISSION,
                default=None,
                index='FieldIndex|schema',
                widget=IdWidget(label='User name',
                                description='Enter the user name you want, usually something ' + \
                                            'like \'jsmith\'.  Do not use spaces or special ' + \
                                            'characters.  This is the name you use to log in.',
                                display_autogenerated=0,
                                ),
                ),
))


contact_schema = FieldList((
    StringField('fullname',
                default='',
                mode='rw',
                read_permission=VIEW_PUBLIC_PERMISSION,
                write_permission=EDIT_REGISTRATION_PERMISSION,
                searchable=1,
                index='TextIndex|schema',
                widget=StringWidget(label='Full name',
                                    description='Enter your full name here.',)
                ),

    ObjectField('email',
                required=1,
                mode='rw',
                read_permission=VIEW_PUBLIC_PERMISSION,
                write_permission=EDIT_REGISTRATION_PERMISSION,
                validators=('isEmail',),
                index='FieldIndex|schema',
                searchable=1,
                widget=StringWidget(label='E-mail',
                                    description='Enter your e-mail address here.',)
                ),
))


plone_schema = FieldList((
    ObjectField('wysiwyg_editor',
                mode='rw',
                read_permission=VIEW_OTHER_PERMISSION,
                write_permission=EDIT_OTHER_PERMISSION,
                vocabulary='editors',
                enforceVocabulary=1,
                widget=SelectionWidget(format='flex',
                                       label='Content editor',
                                       description='Select the editor that you would like to use ' + \
                                                   'for editing content more easily. Content editors ' + \
                                                   'often have specific browser requirements.')
                ),
    
    BooleanField('formtooltips',
                 default=1,
                 mode='rw',
                 read_permission=VIEW_OTHER_PERMISSION,
                 write_permission=EDIT_OTHER_PERMISSION,
                 searchable=0,
                 widget=BooleanWidget(label='Form help',
                                      description='Indicate whether you want the form help pop-ups to be displayed.')
                ),

    BooleanField('visible_ids',
                default=1,
                mode='rw',
                read_permission=VIEW_OTHER_PERMISSION,
                write_permission=EDIT_OTHER_PERMISSION,
                widget=BooleanWidget(label='Display names',
                                     description='Indicate whether you want Names (also known as IDs) to be ' + \
                                                 'visible and editable when editing contents. If you choose not ' + \
                                                 'to display Names, they will be generated automatically.')
                ),

    ObjectField('portal_skin',
                mode='rw',
                default=None,
                read_permission=VIEW_OTHER_PERMISSION,
                write_permission=EDIT_OTHER_PERMISSION,
                accessor='getPortalSkin',
                vocabulary='available_skins',
#                required=1,
#                enforceVocabulary=1,
                searchable=0,
                widget=SelectionWidget(format='flex',
                                       label='Look',
                                       description='Choose the appearance of the site. Several styles are available.')
                ),

    ImageField('portrait',
               mode='rw',
               max_size=(150,150),
               read_permission=VIEW_PUBLIC_PERMISSION,
               write_permission=EDIT_OTHER_PERMISSION,
               required=0,
               searchable=0,
               widget=ImageWidget(label='Portrait',
                                  description='To add a new portrait, click the <strong>Browse</strong> button and select ' + \
                                            'a picture of yourself. Recommended size is 75 pixels wide, 100 pixels tall)')
               ),

))


security_schema = FieldList((
    StringField('password',
                mutator='_setPassword',
                accessor='getPassword',
                mode='w',
                read_permission=VIEW_SECURITY_PERMISSION,
                write_permission=EDIT_PASSWORD_PERMISSION,
                searchable=0,
                widget=PasswordWidget(label='Password',
                                      description='Enter a new password (leave blank to keep your current password)')
                ),

    StringField('confirm_password',
                mutator='_setConfirmPassword',
                accessor='_getConfirmPassword',
                mode='w',
                read_permission=VIEW_SECURITY_PERMISSION,
                write_permission=EDIT_PASSWORD_PERMISSION,
                searchable=0,
                widget=PasswordWidget(label='Confirm password',
                                      description='Confirm your new password')
                ),

    BooleanField('mail_me',
                mutator='setMailMe',
                default=0,
                searchable=0,
                mode='w',
                write_permission=EDIT_PASSWORD_PERMISSION,
                widget=BooleanWidget( label='Mail password', description="Have your password mailed to you after you change it"),
                ),
                
    LinesField('roles',
               default=('Member',),
               mutator='setRoles',
               accessor='getRoles',
               mode='rw',
               read_permission=VIEW_SECURITY_PERMISSION,
               write_permission=EDIT_SECURITY_PERMISSION,
               vocabulary='valid_roles',
#               enforceVocabulary=1, # don't enforce vocabulary because getRoles() adds some extra roles
               multiValued=1,
               searchable=0,
               index='KeywordIndex',
               widget=MultiSelectionWidget(label='Roles',
                                           description='Select the security roles for this user')
               ), 

    LinesField('groups',
               default=(),
               mutator='setGroups',
               accessor='getGroups',
               mode='rw',
               read_permission=VIEW_SECURITY_PERMISSION,
               write_permission=EDIT_SECURITY_PERMISSION,
               vocabulary='valid_groups',
#               enforceVocabulary=1, # don't enforce vocabulary because getRoles() adds some extra roles
               multiValued=1,
               searchable=0,
               index='KeywordIndex',
               widget=MultiSelectionWidget(label='Groups',
                                           description='Select groups this user')
               ), 

    
    LinesField('domains',
               default=(),
               mutator='setDomains',
               accessor='getDomains',
               mode='rw',
               read_permission=VIEW_SECURITY_PERMISSION,
               write_permission=EDIT_SECURITY_PERMISSION,
               multivalued=1,
               searchable=0,
               index='KeywordIndex',
               widget=LinesWidget(label='Domains',
                                  description='If you would like to restrict this user to logging in only from certain domains, enter those domains here.')
               ),

               
))


content_schema = id_schema + contact_schema + plone_schema + security_schema

#    DateTimeField('login_time',
#                  default='2000/01/01',  # for Plone 1.0.1 compatibility
#                  mode='r',
#                  read_permission=VIEW_OTHER_PERMISSION,
#                  write_permission=EDIT_OTHER_PERMISSION,
#                  searchable=0,
#                  widget=StringWidget(label="Login time",
#                                      visible=-1,)),
#    
#    DateTimeField('last_login_time',
#                  default='2000/01/01',  # for Plone 1.0.1 compatibility
#                  mode='r',
#                  read_permission=VIEW_OTHER_PERMISSION,
#                  write_permission=EDIT_OTHER_PERMISSION,
#                  searchable=0,
#                  widget=StringWidget(label="Last login time",
#                                      visible=-1,)),

_marker = []

class Member(VariableSchemaSupport, BaseContent):
    """A description of a member"""

    if memberdata_interface:
        __implements__ = IMemberData, IBaseContent
    else:
        __implements__ = IBaseContent

    security = ClassSecurityInfo()

    portal_type = meta_type = "Member"

    # Note that we override BaseContent.schema
    schema = content_schema + ExtensibleMetadata.schema

    # for Plone compatibility -- managed by workflow state
    listed = 0
    login_time = '2000/01/01'
    last_login_time = '2000/01/01/'


    def dump(self, st=''):
        import sys
        sys.stdout.write(str(st)+'\n')
        sys.stdout.write('_user = %s\n\n' % (str(self._userPath)))

    
    ##IMPL DETAILS
    def __init__(self, userid):
        BaseContent.__init__(self, userid)
        self.id = str(userid)
        self._userPath = None
        self._has_user = None
        self.password = ''
        self.roles = ()
        self.domains = ()

        # for plone compatibility
        self.listed = 0
        self.login_time = '2000/01/01'
        self.last_login_time = '2000/01/01'


    def view(self, **kwargs):
        """View action"""
        #XXX CMF1.4 compatibility
        try:
            actions = self.getTypeInfo().getActions()
            for action in actions:
                if action.get('id', None) == 'view':
                    if _verifyActionPermissions(self, action):
                        action = self.restrictedTraverse(action['action'])
                        if action is not None:
                            return action(**kwargs)
        except AttributeError:
            actions = self.getTypeInfo().listActions()
            for action in actions:
                if action.id == 'view':
                    if _verifyActionPermissions(self, action):
                        url=action.action(createExprContext(self.aq_parent,getToolByName(self,'portal_url').getPortalObject(),self))
                        path=urllib.splithost(urllib.splittype(url)[1])[1]
                        action = self.restrictedTraverse(path)
                        if action is not None:
                            return action(**kwargs)

        raise 'Unauthorized', ('No accessible views available for %s' %
                               '/'.join(self.getPhysicalPath()))


    def __str__(self):
        return self.id

    
    def __call__(self, *args, **kwargs):
        return self.id

    # ########################################################################
    # User interface
    security.declarePublic('Title')
    def Title(self):
        return self.id


    security.declarePublic('getUserName')
    def getUserName(self):
        """Return the username of a user"""
        return self.getUser().getUserName()


#    security.declareProtected(VIEW_PUBLIC_PERMISSION, 'getPortrait')
#    def getPortrait(self):
#        """Return a member's portrait using the Plone portal_membership methods."""
#        membership_tool = getToolByName(self, 'portal_membership')
#        return membership_tool.getPersonalPortrait(self.getId(), 1)


    security.declarePrivate('getPassword')
    def getPassword(self):
        """Return the password of the user."""
        return self.getUser()._getPassword()


    security.declarePublic('getRoles')
    def getRoles(self):
        """Return the list of roles assigned to a user."""
        roles=()
        try:
            user=self.getUser()
            if user is None:
                # Temporary fix: when reimporting a plone portal with
                # CMFMember it breaks on catalog indexing because the 
                # portal_memberdata gets imported before acl_users
                # XXX: find a way to force acl_users to be imported before 
                # CMFMember stuff
                return ()
            
            if hasattr(user,'getUserRoles'):
                roles=user.getUserRoles()
            else:
                roles=user.getRoles()
        except TypeError:
            #XXX The user is not in this acl_users so we get None
            if self.getUser().roles is None:
                self.getUser().roles=('Member',)
            roles=self.getUser().getRoles()
            
        # filter out Authenticated, etc
        allowed = self.valid_roles()
        return tuple([r for r in roles if r in allowed])


    security.declarePublic('getDomains')
    def getDomains(self):
        """Return the list of domain restrictions for a user"""
        domains=()
        try:
            user=self.getUser()
            if user is None:
                # temp fix:
                # when reimporting a  plone portal with
                # CMFMember it breaks on catalog indexing
                # because the posrtal_memberdata gets 
                # imported before acl_users
                # XXX: find a solution to force acl_users to
                # be imported before CMFMember stuff
                return ()
            
            domains=user.getDomains()
        except TypeError:
            if self.getUser().domains is None:
                self.getUser().domains=()
            domains=self.getUser().getDomains()
        return domains


    security.declarePublic('getRolesInContext')
    def getRolesInContext(self, object):
        """Return the list of roles assigned to the user,
           including local roles assigned in context of
           the passed in object."""
        return self.getUser().getRolesInContext(object)


    security.declarePublic('has_role')
    def has_role(self, roles, object=None):
        """Check to see if a user has a given role or roles."""
        return self.getUser().has_role(roles, object)


    # dummy method
    def _setConfirmPassword(self, value):
        pass


    # dummy method
    def _getConfirmPassword(self):
        return ''


    def _setPassword(self, password):
        if password:
            self.setSecurityProfile(password=password)


    security.declarePrivate('setRoles')
    def setRoles(self, roles):
        roles = self._stringToList(roles)
        self.setSecurityProfile(roles=roles)


    security.declarePrivate('setDomains')
    def setDomains(self, domains):
        # get rid of empty string domains!
        domains = self._stringToList(domains)
        self.setSecurityProfile(domains=domains)

    
    security.declarePrivate('setSecurityProfile')
    def setSecurityProfile(self, password=None, roles=None, domains=None):
        """Set the user's basic security profile"""
        if password is None:
            password = self.password
        else:
            self.password = password
        if roles is None:
            roles = self.roles
        else:
            self.roles = roles
        if domains is None:
            domains = self.domains
        else:
            self.domains = domains

        if self.hasUser():
            # if our user lives in a user folder, do this the right way
            self.getUser().aq_parent.userFolderEditUser(self.id, password, roles, domains)

            if hasattr(self, '_v_user'):
                delattr(self, '_v_user')  # remove the cached user
        else:
            # we have a temporary user in hand -- set its attributes by hand
            user = self.getUser()
            if hasattr(user, 'changePassword'):
                # for GRUF
                user.changePassword(password)
            else:
                # for ordinary acl_users
                user.__ = password
            user.roles = roles
            user.domains = domains


    security.declareProtected(EDIT_PASSWORD_PERMISSION, 'setMailMe')
    def setMailMe(self, value):
        if value:
            self.mailPassword()


    security.declarePublic('getPortalSkin')
    def getPortalSkin(self):
        try:
            skins_tool = getToolByName(self, 'portal_skins')
            if self.portal_skin in skins_tool.getSkinSelections():
                return self.portal_skin
            else:
                return skins_tool.getDefaultSkin()
        except AttributeError:
            return self.portal_skin

    #for compatibility to CMFCore member handling
    def setMemberProperties(self,props):
        return self.edit(**props)
    
    ######################################
    # group management methods
    
    security.declarePrivate('setGroups')
    def setGroups(self,groups):
        '''assigns the groups to the user using GroupUserFolder'''
        
        acl_users=getToolByName(self,'acl_users')
        groups=self._stringToList(groups) #clean out the empty ones
        
        if not hasattr(acl_users,'getGroupPrefix'):
            return # do nothing if GRUF is not installed

        pref=acl_users.getGroupPrefix()
        
        roles=tuple([r for r in self.getRoles() if not r.startswith(pref) ])+tuple([pref+g for g in groups])
        self.setSecurityProfile(roles=roles)
        self.getUser()
        
        
    def getGroups(self):
        ''' fetches the groups from GRUF '''
        acl_users=getToolByName(self,'acl_users')
        
        user=self.getUser()
        
        if not hasattr(user,'getGroups'): #return empty list if user comes another acl_user
            return []
        
        groups=user.getGroups()
        try:
            res = [g.getUserNameWithoutGroupPrefix() for g in groups if g.getUserNameWithoutGroupPrefix()]
        except AttributeError:
            # then the groups come as array of strings
            pref=acl_users.getGroupPrefix()
            res = [g[len(pref):] for g in groups if g != pref]
            
        return res
    
    def getRawGroups(self):
        '''fetches the Group names from GRUF with prefix '''
        user=self.getUser()
        if not hasattr(user,'getGroups'): #return empty list if user comes another acl_user
            return []

        acl_users=getToolByName(self,'acl_users')
        pref=acl_users.getGroupPrefix()
        
        groups=user.getGroups()
        try:
            res = [g.getId() for g in groups if g.getId() != pref]
        except AttributeError:
            res = [g for g in groups if g != pref]
        return res
        
    def valid_groups(self):
        acl_users=getToolByName(self,'acl_users')
        if not hasattr(acl_users,'getGroups'):
            return []
        groups=acl_users.getGroups()
        res = [g.id for g in groups if g.id]
        return res
    
    
    
    # ########################################################################
    # Validators and vocabulary methods

    security.declarePrivate('validate_id')
    def validate_id(self, id):
        # no change -- ignore
        if self.id and (not id or id == self.id):
            return None

        memberdata_tool = getToolByName(self, 'portal_memberdata')
        if memberdata_tool.get(id, None):
            return 'This name is already in use.  Please choose another.'
        
        registration_tool = getToolByName(self, 'portal_registration')
        if registration_tool.isMemberIdAllowed(id):
            return None
        else:
            return 'Names can only include letters and numbers.  Please choose another.'

    
    security.declarePrivate('validate_password')
    def validate_password(self, password):
        # no change -- ignore
        if not password:
            return None

        registration_tool = getToolByName(self, 'portal_registration')
        return registration_tool.testPasswordValidity(password)


    security.declarePrivate('validate_roles')
    def validate_roles(self, roles):
        roles = self._stringToList(roles)
        valid = self.valid_roles() + ('Authenticated',) + tuple(self.getRawGroups())
        
        for r in roles:
            if r not in valid:
                return '%s is not a valid role.' % (r)
        return None


    security.declarePrivate('post_validate')
    def post_validate(self, REQUEST, errors):
        if REQUEST and not(errors.get('password', None)) and not(errors.get('confirm_password', None)):
            if REQUEST.get('password', None) != REQUEST.get('confirm_password', None):
                errors['password'] = errors['confirm_password'] = \
                    'Your password and confirmation did not match. ' \
                     + 'Please try again.'


    security.declarePublic('isValid')
    def isValid(self):
        """ Check to make sure a Member object's fields satisfy schema constraints"""
        errors = {}
        # make sure object has required data and metadata
        self.Schema().validate(self, None, errors, 1, 1)
        if errors:
#            import sys
#            sys.stdout.write('isValid, errors = %s\n' % (str(errors)))
            return 0
        return 1


    # Vocabulary methods
    def editors(self):
        return self.portal_properties.site_properties.available_editors


    def valid_roles(self):
        roles = list(self.getUser().valid_roles())
        # XXX - how should we handle roles for users in root.acl_users?
        # XXX - can they assume all portal roles or just root roles?
#        portal = getToolByName(self, 'portal_url').getPortalObject()
#        roles = list(portal.acl_users.valid_roles())
        # remove automatically added roles
        while 'Authenticated' in roles:
            roles.remove('Authenticated')
        while 'Anonymous' in roles:
            roles.remove('Anonymous')
        return tuple(roles)


    # FIXME -- need to figure out a permission that will allow a manager
    # of some sort access to all skins, even if portal_skins.allowAny is false
    def available_skins(self):
        skins_tool = getToolByName(self, 'portal_skins')
        if skins_tool.getAllowAny():
            return getToolByName(self, 'portal_skins').getSkinSelections()
        else:
            return [self.getPortalSkin()]


    def getDefaultSkin(self):
        return getToolByName(self, 'portal_skins').getDefaultSkin()
    
    # ########################################################################
    # Contract with portal_membership

    security.declarePublic('getMemberId')
    def getMemberId(self):
        """Get the member id """
        return self.getUserName()

    
    security.declareProtected(EDIT_OTHER_PERMISSION, 'setProperties')
    def setProperties(self, mapping=None, **kwargs):
        """assign all the props to member attributes, we expect
        to be able to find a mutator for each of these props
        """
        #We know this is an Archetypes based object so we look for
        #mutators there first

        # if mapping is not a dict, assume it is REQUEST
        if mapping:
            if not type(mapping) == type({}):
                data = {}
                for k,v in mapping.form.items():
                    data[k] = v
                mapping = data
        else:
            mapping = {}

        if kwargs:
            # mapping could be a request object thats not really a dict,
            # this is what we get
            mapping.update(kwargs)

        self.update(**mapping)

        # FIXME -- there has to be a better way!!
        if mapping.has_key('login_time'):
            self.login_time = mapping['login_time']
        if mapping.has_key('last_login_time'):
            self.last_login_time = mapping['last_login_time']


    security.declarePrivate('setMemberProperties')
    def setMemberProperties(self, mapping):
        self.setProperties(mapping)


    def _getProperty(self, id):
        """Try to get a member property.  If the property is not found,
        raise an AttributeError"""
        schema = self.Schema()
        if schema.get(id, None):
            accessor = getattr(self, schema.get(id).accessor, None)
            value = accessor()
        else:
            base = aq_base(self)
            value = getattr(base, id)
        return value


    security.declarePublic('getProperty')
    def getProperty(self, id, default=_marker):
        try:
            return self._getProperty(id)
        except AttributeError:

            # member does not have a value for given property
            # try memberdata_tool for default value
            memberdata_tool = getToolByName(self, 'portal_memberdata')
            tool_value = memberdata_tool.getProperty(id, _marker)
            user_value = getattr(self.getUser(), id, _marker)

            # If the tool doesn't have the property, use user_value or default
            if tool_value is _marker:
                if user_value is not _marker:
                    return user_value
                elif default is not _marker:
                    return default
                else:
                    raise ValueError, 'The property %s does not exist' % id
    
            # If the tool has an empty property and we have a user_value, use it
            if not tool_value and user_value is not _marker:
                return user_value
    
            # Otherwise return the tool value
            return tool_value


    security.declarePublic('getUser')
    def getUser(self):
        if self._userPath is None:
            self._v_user = (self._createUser(create_acl_user=0),)
            return self._v_user[0]
        if not hasattr(self, '_v_user') or self._v_user is None:
            if self._has_user:
                self._v_user = (self._pathToUser(self._userPath),)
            else:
                acl_users = getToolByName(self, 'portal_url').getPortalObject().acl_users
                self._v_user = (AccessControl.User.SimpleUser(self.id, self.password, self.roles, self.domains).__of__(acl_users),)

        return self._v_user[0]

    def _absattr(self, attr):
        if callable(attr): return attr()
        return attr

    def _userToPath(self, user):
        if user is None:
            return None
        uid=user.getId()
        if uid is None: return uid
        db=user.aq_inner.aq_parent
        path=[self._absattr(db.id)]
        root=db.getPhysicalRoot()
        while 1:
            db=getattr(db,'aq_inner', None)
            if db is None: break
            db=db.aq_parent
            if db is root: break
            id=db.id
            if type(id) is not type(''):
                try: id=id()
                except: id=str(id)
            path.append(id)

        path.reverse()
        path.append(uid)
        return path


    def _pathToUser(self, path):
        if not path:
            return None
        folder = self.getPhysicalRoot()
        for p in path[:-1]:
            folder = getattr(folder, p)
        u=folder.getUser(path[-1])
        if u is None:
                # temp fix:
                # when reimporting a  plone portal with
                # CMFMember it breaks on catalog indexing
                # because the posrtal_memberdata gets 
                # imported before acl_users
                # XXX: find a solution to force acl_users to
                # be imported before CMFMember stuff
            return u
        
        return u.__of__(folder)



    def hasUser(self):
        if self._has_user is None:
            self._createUser(create_acl_user=0)
        return self._has_user

        # XXX should context be self.acl_users or self._user's original context?
#        return aq_base(self._user).__of__(self.acl_users)


    # ########################################################################
    # Overrides of base class mutators that trigger workflow transitions
    
    def update(self, **kwargs):
        membership_tool = getToolByName(self, 'portal_membership')
        updateSelf = membership_tool.getAuthenticatedMember().getUserName() == self.getUserName()
        ret = BaseContent.update(self, **kwargs)
        if updateSelf:
            self._updateCredentials()
        # invoke any automated workflow transitions after update
        triggerAutomaticTransitions(self)
        return ret


    def processForm(self, data=1, metadata=0):
        membership_tool = getToolByName(self, 'portal_membership')
        updateSelf = membership_tool.getAuthenticatedMember().getUserName() == self.getUserName()
        ret = BaseContent.processForm(self, data, metadata)
        if updateSelf:
            self._updateCredentials()
        # invoke any automated workflow transitions after update
        triggerAutomaticTransitions(self)
        return ret


    # ########################################################################
    # Methods triggered by workflow transitions

    security.declarePrivate('register')
    def register(self):
        try:
            registration_tool = getToolByName(self, 'portal_registration')
            user_created = 0
            # create a real user
            if not self.hasUser():
                # Limit the granted roles.
                # Anyone is always allowed to grant the 'Member' role.
                roles = self.getRoles()
                _limitGrantedRoles(roles, self, ('Member',))
                self.setRoles(roles)
                self._createUser(create_acl_user=1)
                user_created = 1
    
            # make the user the owner of the current member object
            self.changeOwnership(self.getUser(), 1)
            self.manage_setLocalRoles(self.getUserName(), ['Owner'])
            # XXX - should we invoke this for members with users in the Zope root acl_user?
            registration_tool.afterAdd(self, id, self.getPassword(), None)
            self.updateListed()
    
            # only send mail if we had to create a new user -- this avoids
            # sending mail to users who are already registered at the Zope root level
            if user_created:
                registration_tool.registeredNotify(self.getUserName())
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('disable')
    def disable(self):
        try:
            self._setPassword(self._generatePassword())
            workflow_tool = getToolByName(self, 'portal_workflow')
            self.old_state = workflow_tool.getInfoFor(self, 'review_state', '')
            self.updateListed()
        except:
             # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('enable')
    def enable(self):
        try:
            if hasattr(self, 'old_state'):
                delattr(self, 'old_state')
            self.updateListed()
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('makePublic')
    def makePublic(self):
        try:
            self.updateListed()
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('makePrivate')
    def makePrivate(self):
        try:
            self.updateListed()
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('updateListed')
    def updateListed(self):
        """Extract the correct value of the Member's 'listed' attribute from
           current security settings."""
        membership_tool = getToolByName(self, 'portal_membership')
        self.listed = membership_tool.checkPermission(VIEW_PUBLIC_PERMISSION, self)
        

    # ########################################################################
    security.declareProtected(EDIT_ID_PERMISSION, 'setId')
    def setId(self, id):
        if not id:
            id = self.getId()
        memberdata=getToolByName(self, 'portal_memberdata')
        memberdata.manage_renameObjects( (self.getId(),), (id,) )


    def _notifyOfCopyTo(self, container, op=0):
        try:
            Member.inheritedAttribute('_notifyOfCopyTo')(self, container, op)
            if op:
                self._v_old_user = [self.getUser()] # get user with aq context, store in a list to keep from stomping wrapper
        except:
            logException()
            raise


    security.declarePrivate('manage_afterAdd')
    def manage_afterAdd(self, object, container):
        try:
            BaseContent.manage_afterAdd(self, object, container)

            if hasattr(object, '_migrating'):
                return
            
            old_user = getattr(object, '_v_old_user', None)
            if old_user:
                old_user = old_user[0]
                if old_user and object.id == old_user.getUserName():
                    return

            if hasattr(object, '_v_old_user'):
                # object has been renamed
                delattr(object, '_v_old_user')
                if object.hasUser():
                    # The old member had a real user, so we need to 
                    # create a real user for the new member and transfer
                    # ownership and local roles to the new member's user
                    object._createUser(create_acl_user=1)
                    portal = getToolByName(self, 'portal_url').getPortalObject()
                    # change local roles and content ownership info
                    old_owner_info = Owned.ownerInfo(old_user)
                    new_owner = object.getUser()
                    object._changeUserInfo(portal, old_owner_info, new_owner)

                    # make the user the owner of the current member object
                    object.manage_delLocalRoles([old_user.getUserName()])
                    object.changeOwnership(new_owner, 1)
                    object.manage_setLocalRoles(object.getUserName(), ['Owner'])

                    # Delete the old user object if it was from portal.acl_users but not
                    # if it was from zope_root.acl_users.
                    if object._isPortalUser(old_user):
                        # delete the old user
                        if portal.acl_users.getUser(old_user.getUserName()):
                            portal.acl_users.userFolderDelUsers([old_user.getUserName()])
        except:
            logException()
            raise


    security.declarePrivate('manage_afterClone')
    def manage_afterClone(self, object):
        try:
            if self.hasUser():
                # the copied member had a real user -- create a real user for the copy
                self._createUser(create_acl_user=1)
                # make the user the owner of the current member object
                self.manage_delLocalRoles(self.users_with_local_role('Owner'))
                self.changeOwnership(self.getUser(), 1)
                self.manage_setLocalRoles(self.getUserName(), ['Owner'])
        except:
            logException()
            raise


    security.declarePrivate('manage_beforeDelete')
    def manage_beforeDelete(self, item, container):
        try:
            if hasattr(self, '_v_old_user'):
                # if we are in the midst of a move, do nothing
                return

            if hasattr(self, '_migrating'):
                # if we are in the midst of a migration, do nothing
                return

            # XXX FIXME this is a hack
            # Here's what this addresses (I think): when a site is deleted,
            # acl_users may be deleted before portal_memberdata.  The member
            # object in portal_memberdata holds a reference to the user object
            # in acl_users.  When acl_users gets deleted, the user object
            # remains because its refcount is > 0, but it is now unwrapped.
            # At this point we should just bail.
            if self.getUser() == None:
                self._v_user = None # remove references to user
                return

            portal = getToolByName(self, 'portal_url').getPortalObject()

            # make sure user comes from the portal.acl_users folder and not
            # zope.acl_users or somewhere above the portal
            if self._isPortalUser(self.getUser()): 
                # recurse through the portal and delete all of the user's content
                # XXX we should create some other options here
                self._changeUserInfo(portal, Owned.ownerInfo(self.getUser()))
                # Delete the User object if it's in the current portal's acl_users folder.
                if portal.acl_users.getUser(self.id):
                    portal.acl_users.userFolderDelUsers([self.id])
            self._v_user = None # remove references to user
            BaseContent.manage_beforeDelete(self, item, container)
        except:
            logException()
            raise


    def _isPortalUser(self, user):
        """Test whether a user object comes from the portal's acl_users folder"""
        # (The ugly comparison is because (1) the user's aq_parent is set to
        # portal.acl_users, so we first need to do aq_inner, and (2) it appears
        # that the == function for acl_users is not very smart, so we need to
        # see if the acl_users folders have the same parent.)
        portal = getToolByName(self, 'portal_url').getPortalObject()

        return user.aq_inner.aq_parent.aq_inner.aq_parent == \
            portal.acl_users.aq_inner.aq_parent
        

    security.declarePrivate('setUser')
    def setUser(self, user):
        # make sure the user is wrapped with an acquisition context
        base = getattr(user, 'aq_base', None)
        if base is None:
            # look up the user by id
            u = self._getUserById(user.getUserName())
            if u:
                # wrapped user found
                user = u
            else:
                # user not found -- wrap it in portal.acl_users
                user = user.__of__(getToolByName(self, 'portal_url').getPortalObject().acl_users)
        else:
            # re-wrap user to get portal_membership out of the aquisition chain
            user = aq_base(user).__of__(aq_inner(aq_parent(user)))
        self._userPath = self._userToPath(user)
        assert self._userPath != []
        acl_users = aq_parent(user)
        self._has_user = acl_users.getUser(user.getUserName()) is not None
        assert(user.getUserName() == self.id)
        if hasattr(self, '_v_user'):
            delattr(self, '_v_user')  # remove the cached user

        if hasattr(user, '_getPassword'):
            # for GRUF
            self.password = user._getPassword()
            self.roles = user.getRoles()
            self.domains = user.getDomains()
        else:
            # for ordinary acl_users
            self.password = user.__
            self.roles = user.roles
            self.domains = user.domains


    def _updateCredentials(self):
        if self.REQUEST:
            # don't log out the current user
            if self._has_user and hasattr(self.getUser().aq_parent.aq_base, 'credentialsChanged'):
                # Use an interface provided by LoginManager.
                self.getUser().aq_parent.credentialsChanged(self.getUser(), id, password)
            else:
                p = getattr(self.REQUEST, '_credentials_changed_path', None)
                if p is not None:
                    # Use an interface provided by CookieCrumbler.
                    change = self.restrictedTraverse(p)
                    change(self.getUser(), self.id, self.getPassword())


    def _createUser(self, create_acl_user=0):
        acl_users = getToolByName(self, 'portal_url').getPortalObject().acl_users
        if not create_acl_user:
            user = AccessControl.User.SimpleUser(self.id, self.password, self.roles, self.domains).__of__(acl_users)
            self._has_user = 0
        else:
            acl_users.userFolderAddUser(self.id, self.password, self.roles, self.domains)
            user = acl_users.getUser(self.id).__of__(acl_users)
            self._has_user = 1
        self._userPath = self._userToPath(user)
        if hasattr(self, '_v_user'):
            delattr(self, '_v_user')
        return user

    def _getUserFolderForUser(self, id=None):
        f = getToolByName(self, 'portal_url').getPortalObject()
        if id is None:
            return f.acl_users
        while 1:
            if not hasattr(f, 'objectIds'):
                return
            if 'acl_users' in f.objectIds():
                if hasattr(f.acl_users, 'getUser'):
                    user = f.acl_users.getUser(id)
                    if user is not None:
                        return f.acl_users
            if hasattr(f, 'getParentNode'):
                f = f.getParentNode()
            else:
                return None


    def _getUserById(self, id):
        """A utility method for finding a user by searching through
        portal.acl_users as well as the acl_users folders for all
        zope folders containing portal.
        
        Returns the user in the acquisition context of its containing folder"""
        acl_users = self._getUserFolderForUser(id)
        if acl_users is None:
            return None
        return acl_users.getUser(id).__of__(acl_users)


    def _changeUserInfo(self, context, old_user_info, new_user=None):
        """A utility method for altering information related to a user
        when a member is renamed or deleted"""
        old_user_id = old_user_info[1]
        if new_user:
            new_user_id = new_user.getUserName()
        else:
            new_user_id = None

        if context.isPrincipiaFolderish:
            for o in context.objectValues():
                if self._changeUserInfo(o, old_user_info, new_user):
                    # delete object if need be
                    if o != self:
                        context.manage_delObjects([o.getId()])
                    
            # remove any local roles the user may have had
            if new_user_id is not None:
                # transfer local roles for old user to local roles for new user
                roles = context.get_local_roles_for_userid(old_user_id)
                if roles:
                    context.manage_addLocalRoles(new_user_id, roles)
                context.manage_delLocalRoles([old_user_id])
            else:
                # delete local roles for old user
                context.manage_delLocalRoles([old_user_id])

        # if this object is owned by the user that is being deleted,
        # either change its ownership to new_owner or mark it for deletion
        owner = context.getOwner(1)
        if owner == old_user_info:
            if new_user_id is not None:
                self._changeOwnership(context, new_user)
            else:
                # mark this object for deletion
                return 1
        return 0


    def _changeOwnership(self, object, user):
        # XXX This is a replacement for Owned.py's changeOwnership function
        # Owned.changeOwnership is lame because when you change the owner of
        # a folder, you also end up changing the owner of all of the folder's
        # contents.
        new=Owned.ownerInfo(user)
        if new is None:
            return # Special user!
        old=aq_get(object, '_owner', None, 1)
        if old==new:
            return
        if old is Owned.UnownableOwner: return
        object._owner=new
        

    # ########################################################################
    def _generatePassword(self):
        try:
            registration_tool = getToolByName(self, 'portal_registration')
            return registration_tool.generatePassword()
        except AttributeError:

            try:
                password = ''
                n = len(RegistrationTool.password_chars)
                for i in range(0,6):
                    password += RegistrationTool.password_chars[random.randint(0,n-1)]
                return password
            except:
                logException()
                raise

    # replacement for portal_registration's mailPassword function
    security.declareProtected(MAIL_PASSWORD_PERMISSION, 'mailPassword')
    def mailPassword(self):
        """ Email a forgotten password to a member."""
        # assert that we can actually get an email address, otherwise
        # the template will be made with a blank To:, this is bad
        if not self.getProperty('email'):
            raise 'ValueError', 'Member does not have an email address.'
        
        # Rather than have the template try to use the mailhost, we will
        # render the message ourselves and send it from here (where we
        # don't need to worry about 'UseMailHost' permissions).
        mail_text = self.mail_password_template( self
                                               , self.REQUEST
                                               , member=self
                                               , password=self.getPassword()
                                               )
        host = self.MailHost
        host.send( mail_text )
        return self.mail_password_response( self, self.REQUEST )


    # ########################################################################
    # utility methods

    def _stringToList(self, s):
        if s is None:
            return []
        if isinstance(s, types.StringType):
            # split on , or \n and ignore \r
            s = s.replace('\r',',')
            s = s.replace('\n',',')
            s = s.split(',')
        s= [v.strip() for v in s if v.strip()]
        s = filter(None, s)
        return [o for o in s if o]


    # XXX REFACTOR ME
    # This is used for a hack in MemberDataTool
    def _getTypeName(self):
        return 'CMFMember Content'


    # ########################################################################
    # Migration methods.  Used to migrate CMFCore member data to Member
    # objects or to migrate from from one type of member objects to another.
        
    def _migrate(self, old_member, excluded_fields, out):
        """Set Member attributes using values from old_member"""

        if type(old_member) == type({}):
            properties = old_member['properties']
            fields = self.Schema().fields() + ['listed', 'login_time', 'last_login_time']
            for new_field in fields:
                if type(new_field) != type(''):
                    name = new_field.getName()
                if name not in ['id', 'password', 'roles', 'domains'] and \
                   name not in excluded_fields: # fields managed by user object
                    try:
                        value = properties.get(name)
                        self._migrateSetNewValue(name, value, out)
                        print >> out, '%s.%s = %s' % (old_member['user'].getUserName(), name, str(value))
                    except:
                        print >> out, 'Unable to get field %s from member %s' % (name, old_member['user'].getUserName())
                self.setId(old_member['user'].getUserName())

            self.portrait = old_member['portrait']
            self.setUser(old_member['user'])

        else:
            fields = self.Schema().fields() + ['listed', 'login_time', 'last_login_time']
            for new_field in fields:
                if type(new_field) != type(''):
                    name = new_field.getName()
                if name not in ['password', 'roles', 'domains'] and \
                   name not in excluded_fields: # fields managed by user object
                    try:
                        value = self._migrateGetOldValue(old_member, name, out)
                        self._migrateSetNewValue(name, value, out)
                        print >> out, '%s.%s = %s' % (str(old_member.getMemberId()), name, str(value))
                    except:
                        print >> out, 'Unable to get field %s from member %s' % (name, old_member.getUserName())
                        pass

            # move the user over
            self.setUser(old_member.getUser())


    def _migrateGetOldValue(self, old, id, out):
        """Try to get a value from an old member object using a variety of
        methods."""
        old_schema = getattr(old, 'Schema', None)
        if old_schema is not None:
            old_schema = old_schema()

        new_schema = self.Schema()

        if old_schema:
            old_field = old_schema.get(id, None)
            if old_field:
                accessor = getattr(old, old_field.accessor, None)
                if accessor is not None:
                    return accessor()
        new_field = new_schema.get(id)
        accessor = getattr(old, new_field.accessor, None)
        if callable(accessor):
            try:
                return accessor()
            except:
                pass

        if hasattr(old, id):
            return getattr(old, id)
        
        print >> out, 'Unable to get property %s from member %s\n' % (new_field.name, old.getMemberId())
        raise ValueError
    
        
    def _migrateSetNewValue(self, id, value, out):
        """Utility method for setting a Member attribute using a variety of methods"""
        new_schema = self.Schema()
        new_field = new_schema.get(id, None)
        if new_field:
            if new_field.mutator is not None:
                mutator = getattr(self, new_field.mutator)
                mutator(value)
                return
            if hasattr(self, id):
                setattr(self, id, value)
                return
            print >> out, 'Unable to set property %s from member %s\n' % (new_field.name, self.getMemberId())
            raise ValueError
        else:
            if hasattr(self, id):
                setattr(self, id, value)
                return
            print >> out, 'Unable to set property %s from member %s\n' % (id, self.getMemberId())
            raise ValueError

    
    def getSchema(self):
        md_tool = getToolByName(self, 'portal_memberdata')
        return md_tool.getMemberSchema()    
   
registerType(Member)