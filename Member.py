try:
    from Products.CMFCore.interfaces.portal_memberdata import MemberData \
         as IMemberData
    memberdata_interface = 1
except:
    memberdata_interface = 0

import types
import copy
import urllib
import random

from DateTime import DateTime

from AccessControl import ClassSecurityInfo, ModuleSecurityInfo, User
from AccessControl.PermissionRole import rolesForPermissionOn
from Acquisition import aq_inner, aq_parent, aq_base, aq_chain, aq_get
from ZODB.POSException import ConflictError

from Products import CMFCore
from Products.CMFCore import CMFCorePermissions
from Products.CMFCore.utils import getToolByName, _limitGrantedRoles, \
     _verifyActionPermissions
from Products.CMFCore.Expression import createExprContext
from Products.Archetypes import registerType
from Products.Archetypes.BaseContent import BaseContent
from Products.Archetypes.debug import log
from Products.Archetypes.interfaces.base import IBaseContent
from Products.Archetypes.ExtensibleMetadata import ExtensibleMetadata
from Products.Archetypes.Field       import *
from Products.Archetypes.Widget      import *
from Products.Archetypes.Schema import Schemata, Schema, MetadataSchema

from Products.CMFMember import MemberPermissions
from Products.CMFMember.MemberPermissions import VIEW_PUBLIC_PERMISSION, \
     EDIT_ID_PERMISSION, VIEW_OTHER_PERMISSION, EDIT_PROPERTIES_PERMISSION, \
     VIEW_SECURITY_PERMISSION, EDIT_PASSWORD_PERMISSION, \
     EDIT_SECURITY_PERMISSION, MAIL_PASSWORD_PERMISSION, ADD_PERMISSION
from Products.CMFMember import RegistrationTool, VERSION
from Products.CMFMember.Extensions.Workflow import triggerAutomaticTransitions
from Products.CMFMember.VariableSchemaSupport import VariableSchemaSupport
from Products.CMFMember.utils import logException, changeOwnership

# generate the addMember method ourselves so we can do some extra
# initialization
security = ModuleSecurityInfo('Products.CMFMember.Member')
security.declareProtected(ADD_PERMISSION, 'addMember')
def addMember(self, id, **kwargs):
    o = Member(id)
    self._setObject(id, o)
    o = getattr(self, id)
    o.initializeArchetype(**kwargs)
    o.getUser()
    o._setPassword(o._generatePassword())


id_schema = Schema((
    StringField('id',
                required=1,
                accessor='getId',
                mutator='setId',
                mode='rw',
                read_permission=VIEW_PUBLIC_PERMISSION,
                write_permission=EDIT_ID_PERMISSION,
                default=None,
                index=('member_catalog/ZCTIndex|FieldIndex|TextIndex:brains',
                       'FieldIndex|TextIndex:brains'),
                widget=IdWidget(
                    label='User name',
                    label_msgid='label_user_name',
                    size=10,
                    maxlength=25,
                    description="Enter a user name, usually something " + \
                        "like 'jsmith'. No spaces or special " + \
                        "characters. User names and passwords are " + \
                        "case sensitive, make sure the capslock key " + \
                        "is not enabled. This is the name used to " + \
                        "log in.",
                    description_msgid='help_user_name_creation_casesensitive',
                    i18n_domain='plone',
                    display_autogenerated=0,
                    macro='memid'
                    ),
                regfield=1,  ### this field is part of the registration form
                ),
))


contact_schema = Schema((
    StringField('fullname',
                default='',
                mode='rw',
                read_permission=VIEW_PUBLIC_PERMISSION,
                write_permission=EDIT_PROPERTIES_PERMISSION,
                index=('member_catalog/ZCTIndex|FieldIndex|TextIndex:brains',
                       'ZCTIndex|FieldIndex|TextIndex:brains'),
                widget=StringWidget(
                    label='Full name',
                    label_msgid='label_full_name',
                    description="Enter full name, eg. John Smith.",
                    description_msgid='help_full_name_creation',
                    i18n_domain='plone',
                    ),
                regfield=1,
                ),

    StringField('email',
                required=1,
                mode='rw',
                read_permission=VIEW_PUBLIC_PERMISSION,
                write_permission=EDIT_PROPERTIES_PERMISSION,
                validators=('isEmail',),
                index=('member_catalog/ZCTIndex|FieldIndex|TextIndex:brains',
                       'ZCTIndex|FieldIndex|TextIndex:brains'),
                widget=StringWidget(
                    label='E-mail',
                    label_msgid='label_email',
                    description="Enter an email address. This is " + \
                        "necessary in case the password is lost. " + \
                        "We respect your privacy and will not give " + \
                        "the address away to any third parties or " + \
                        "expose it anywhere.",
                    description_msgid='help_email_creation',
                    i18n_domain='plone',),
                regfield=1,
                ),
))


plone_schema = Schema((
    StringField('wysiwyg_editor',
                mode='rw',
                read_permission=VIEW_OTHER_PERMISSION,
                write_permission=EDIT_PROPERTIES_PERMISSION,
                vocabulary='editors',
                enforceVocabulary=1,
                widget=SelectionWidget(
                    format='flex',
                    label='Content editor',
                    label_msgid='label_content_editor',
                    description='Select the editor that you would like to use ' + \
                        'for editing content more easily. Content editors ' + \
                        'often have specific browser requirements.',
                    description_msgid='help_content_editor',
                    i18n_domain='plone',
                    )
                ),
    
    BooleanField('formtooltips',
                 default=1,
                 mode='rw',
                 read_permission=VIEW_OTHER_PERMISSION,
                 write_permission=EDIT_PROPERTIES_PERMISSION,
                 widget=BooleanWidget(label='Form help',
                                      label_msgid='',
                                      description='Indicate whether you want the form help pop-ups to be displayed.',
                                      description_msgid='',
                                      i18n_domain='plone',)
                ),

    BooleanField('visible_ids',
                default=1,
                mode='rw',
                read_permission=VIEW_OTHER_PERMISSION,
                write_permission=EDIT_PROPERTIES_PERMISSION,
                widget=BooleanWidget(label='Display names',
                                     label_msgid='label_edit_short_names',
                                     description='Indicate whether you want Names (also known as IDs) to be ' + \
                                                 'visible and editable when editing contents. If you choose not ' + \
                                                 'to display Names, they will be generated automatically.',
                                     description_msgid='help_display_names',
                                     i18n_domain='plone',)
                ),

    StringField('portal_skin',
                mode='rw',
                default=None,
                read_permission=VIEW_OTHER_PERMISSION,
                write_permission=EDIT_PROPERTIES_PERMISSION,
                accessor='getPortalSkin',
                vocabulary='available_skins',
#                required=1,
#                enforceVocabulary=1,
                widget=SelectionWidget(format='flex',
                                       label='Look',
                                       label_msgid='label_look',
                                       description='Choose the appearance of the site. Several styles are available.',
                                       description_msgid='help_look',
                                       i18n_domain='plone',)
                ),

    ImageField('portrait',
               mode='rw',
               max_size=(150,150),
               read_permission=VIEW_PUBLIC_PERMISSION,
               write_permission=EDIT_PROPERTIES_PERMISSION,
               required=0,
               widget=ImageWidget(label='Portrait',
                                  label_msgid='label_portrait',
                                  description='To add a new portrait, click the <strong>Browse</strong> button and select ' + \
                                            'a picture of yourself. Recommended size is 75 pixels wide, 100 pixels tall)',
                                  description_msgid='help_portrait',
                                  i18n_domain='plone',)
               ),

))


security_schema = Schema((
    StringField('password',
                mutator='_setPassword',
                accessor='getPassword',
                mode='w',
                write_permission=EDIT_PASSWORD_PERMISSION,
                
                widget=PasswordWidget(label='Password',
                                      label_msgid='label_password',
                                      description='Enter a new password (leave blank to keep your current password)',
                                      visible = {'view' : 'invisible' },
                                      description_msgid='help_password_creation',
                                      i18n_domain='plone',),
                regfield=1,
                ),

    StringField('confirm_password',
                mutator='_setConfirmPassword',
                accessor='_getConfirmPassword',
                mode='w',
                read_permission=VIEW_SECURITY_PERMISSION,
                write_permission=EDIT_PASSWORD_PERMISSION,
                
                widget=PasswordWidget(label='Confirm password',
                                      label_msgid='label_confirm_password',
                                      description='Confirm your new password',
                                      description_msgid='help_confirm_password',
                                      i18n_domain='plone',),
                regfield=1,
                ),

    BooleanField('mail_me',
                default=0,
                
                mode='w',
                write_permission=EDIT_PASSWORD_PERMISSION,
                widget=BooleanWidget( label='Mail password',
                                      label_msgid='label_mail_password',
                                      description="Have your password mailed to you after you change it",
                                      description_msgid='',
                                      i18n_domain='plone',),
                regfield=1,
                ),
                
    LinesField('roles',
               default=('Member',),
               mutator='setRoles',
               accessor='getFilteredRoles',
               mode='rw',
               read_permission=VIEW_SECURITY_PERMISSION,
               write_permission=EDIT_SECURITY_PERMISSION,
               vocabulary='valid_roles',
#               enforceVocabulary=1, # don't enforce vocabulary because getRoles() adds some extra roles
               multiValued=1,
               index='member_catalog/KeywordIndex|TextIndex:brains',
               widget=MultiSelectionWidget(label='Roles',
                                           label_msgid='label_roles',
                                           description='Select the security roles for this user',
                                           description_msgid='',
                                           i18n_domain='plone',
                                          )
               ),

    LinesField('groups',
               default=(),
               mutator='setGroups',
               accessor='getGroups',
               mode='rw',
               read_permission=VIEW_SECURITY_PERMISSION,
               write_permission=EDIT_SECURITY_PERMISSION,
               vocabulary='valid_groups',
               enforceVocabulary=1,
               multiValued=1,
               index='member_catalog/KeywordIndex|TextIndex:brains',
               widget=MultiSelectionWidget(label='Groups',
                                           label_msgid='label_groups',
                                           description='Indicate the groups to which this member belongs',
                                           description_msgid='',
                                           i18n_domain='plone',)
               ),

    LinesField('domains',
               default=(),
               mutator='setDomains',
               accessor='getDomains',
               mode='rw',
               read_permission=VIEW_SECURITY_PERMISSION,
               write_permission=EDIT_SECURITY_PERMISSION,
               multivalued=1,
               
               widget=LinesWidget(label='Domains',
                                  label_msgid='',
                                  description='If you would like to restrict this user to logging in only from certain domains, enter those domains here.',
                                  description_msgid='',
                                  i18n_domain='plone',)
               ),
))


login_info_schema = Schema((
    DateTimeField('login_time',
                  default='2000/01/01',  # for Plone 1.0.1 compatibility
                  mode='r',
                  read_permission=VIEW_OTHER_PERMISSION,
                  write_permission=EDIT_PROPERTIES_PERMISSION,
                  widget=StringWidget(label="Login time",
                                      modes=('view',),
                                      visible={'edit':'invisible',
                                               'view':'visible'},)),

    DateTimeField('last_login_time',
                  default='2000/01/01',  # for Plone 1.0.1 compatibility
                  mode='r',
                  read_permission=VIEW_OTHER_PERMISSION,
                  write_permission=EDIT_PROPERTIES_PERMISSION,
                  index='member_catalog/DateIndex|FieldIndex:brains',
                  widget=StringWidget(label="Last login time",
                                      modes=('view',),
                                      visible={'edit':'invisible',
                                               'view':'visible'},)),
    ComputedField('listed',
                  mode='r',
                  read_permission=VIEW_OTHER_PERMISSION,
                  expression="context.isListed()",
                  widget=ComputedWidget(label="Listed",
                                        label_msgid='label_listed_status',
                                        modes=('view',),
                                        visible={'edit':'invisible',
                                                 'view':'visible'},
                                        i18n_domain='plone',),)
    ))

content_schema = id_schema + contact_schema + plone_schema + security_schema \
                 + login_info_schema

_marker = []

class Member(VariableSchemaSupport, BaseContent):
    """A description of a member"""

    if memberdata_interface:
        __implements__ = IMemberData, IBaseContent
    else:
        __implements__ = IBaseContent

    security = ClassSecurityInfo()
    archetype_name = portal_type = meta_type = 'Member'

    # Note that we override BaseContent.schema
    schema = content_schema + ExtensibleMetadata.schema

    global_allow = 0

    # for Plone compatibility -- managed by workflow state
    listed = 0
    login_time = '2000/01/01'
    last_login_time = '2000/01/01/'
    # version used in migrating
    version = VERSION

    def __init__(self, userid):
        BaseContent.__init__(self, userid)
        self.id = str(userid)
        self._userInfo = None
        self.password = ''
        self.roles = ()
        self.domains = ()

        # for plone compatibility
        self.listed = 0
        self.login_time = '2000/01/01'
        self.last_login_time = '2000/01/01'


    def view(self, **kwargs):
        """View action"""
        #XXX CMF1.4 compatibility
        try:
            actions = self.getTypeInfo().getActions()
            for action in actions:
                if action.get('id', None) == 'view':
                    if _verifyActionPermissions(self, action):
                        action = self.restrictedTraverse(action['action'])
                        if action is not None:
                            return action(**kwargs)
        except AttributeError:
            actions = self.getTypeInfo().listActions()
            for action in actions:
                if action.id == 'view':
                    if _verifyActionPermissions(self, action):
                        url=action.action(createExprContext(self.aq_parent,getToolByName(self,'portal_url').getPortalObject(),self))
                        path=urllib.splithost(urllib.splittype(url)[1])[1]
                        action = self.restrictedTraverse(path)
                        if action is not None:
                            return action(**kwargs)

        raise 'Unauthorized', ('No accessible views available for %s' %
                               '/'.join(self.getPhysicalPath()))


    def __str__(self):
        return self.id

    
    def __call__(self, *args, **kwargs):
        return self.id

    # ########################################################################
    # User interface
    security.declarePublic('Title')
    def Title(self):
        return self.id


    security.declarePublic('getUserName')
    def getUserName(self):
        """Return the username of a user"""
        return self.getUser().getUserName()


    security.declarePrivate('getPassword')
    def getPassword(self):
        """Return the password of the user."""
        return self.getUser()._getPassword()


    security.declarePublic('getRoles')
    def getRoles(self):
        """Return the list of roles assigned to a user."""
        roles=()
        try:
            user=self.getUser()
            if user is None:
                # Temporary fix: when reimporting a plone portal with
                # CMFMember it breaks on catalog indexing because the 
                # portal_memberdata gets imported before acl_users
                # also fixes case of orphaned member
                # XXX: find a way to force acl_users to be imported before 
                # CMFMember stuff
                return ()
            
            if hasattr(user,'getUserRoles'):
                roles=user.getUserRoles()
            else:
                roles=user.getRoles()
        except TypeError:
            #XXX The user is not in this acl_users so we get None
            if self.getUser().roles is None:
                self.getUser().roles=('Member',)
            roles=self.getUser().getRoles()

        # XXX removing spurious duplicate roles... where do they come from?
        r = list(roles)
        for i in r:
            while r.count(i) > 1:
                r.remove(i)
        roles = tuple(r)
        return roles


    security.declarePublic('getFilteredRoles')
    def getFilteredRoles(self):
        """Return the list of roles EXCEPT for the ones that are
           automatic, i.e. Authenticated and Anonymous.  Used by
           the MemberData UI to prevent folks from removing those
           roles from any members."""
        roles = list(self.getRoles())
        # remove automatically added roles
        for autoRole in ['Authenticated', 'Anonymous']:
            while autoRole in roles:
                roles.remove(autoRole)
        return tuple(roles)


    security.declarePublic('getDomains')
    def getDomains(self):
        """Return the list of domain restrictions for a user"""
        domains=()
        try:
            user=self.getUser()
            if user is None:
                # temp fix:
                # when reimporting a  plone portal with
                # CMFMember it breaks on catalog indexing
                # because the posrtal_memberdata gets
                # imported before acl_users
                # also fixes case of orphaned member
                # XXX: find a solution to force acl_users to
                # be imported before CMFMember stuff
                return ()
            
            domains=user.getDomains()
        except TypeError:
            if self.getUser().domains is None:
                self.getUser().domains=()
            domains=self.getUser().getDomains()
        return domains


    security.declarePublic('getRolesInContext')
    def getRolesInContext(self, object):
        """Return the list of roles assigned to the user,
           including local roles assigned in context of
           the passed in object."""
        return self.getUser().getRolesInContext(object)


    security.declarePublic('has_role')
    def has_role(self, roles, object=None):
        """Check to see if a user has a given role or roles."""
        return self.getUser().has_role(roles, object)


    # dummy method
    def _setConfirmPassword(self, value):
        pass


    # dummy method
    def _getConfirmPassword(self):
        return ''


    def _setPassword(self, password):
        if password:
            self.setSecurityProfile(password=password)


    security.declarePrivate('setRoles')
    def setRoles(self, roles):
        roles = self._stringToList(roles)
        self.setSecurityProfile(roles=roles)


    security.declarePrivate('setDomains')
    def setDomains(self, domains):
        # get rid of empty string domains!
        domains = self._stringToList(domains)
        self.setSecurityProfile(domains=domains)


    security.declarePrivate('setSecurityProfile')
    def setSecurityProfile(self, password=None, roles=None, domains=None):
        """Set the user's basic security profile"""
        if password is None:
            password = self.password
        else:
            self.password = password
        if roles is None:
            roles = self.roles
        else:
            self.roles = roles
        if domains is None:
            domains = self.domains
        else:
            self.domains = domains

        if self.hasUser():
            # if our user lives in a user folder, do this the right way
            aq_parent(aq_inner(self.getUser())).userFolderEditUser(self.id, password, roles, domains)

            if hasattr(self, '_v_user'):
                delattr(self, '_v_user')  # remove the cached user
        else:
            # we have a temporary user in hand -- set its attributes by hand
            user = self.getUser()
            if hasattr(user, 'changePassword'):
                # for GRUF
                user.changePassword(password)
            else:
                # for ordinary acl_users
                user.__ = password
            user.roles = roles
            user.domains = domains


    security.declarePublic('getPortalSkin')
    def getPortalSkin(self):
        portalskin = self.Schema()['portal_skin'].get(self)
        try:
            skins_tool = getToolByName(self, 'portal_skins')
            if portalskin in skins_tool.getSkinSelections():
                return portalskin
            else:
                return skins_tool.getDefaultSkin()
        except AttributeError:
            return portalskin

    #for compatibility to CMFCore member handling
    def setMemberProperties(self,props):
        return self.edit(**props)
    
    ######################################
    # group management methods
    
    security.declarePrivate('setGroups')
    def setGroups(self,groups):
        '''assigns the groups to the user using GroupUserFolder'''
        
        acl_users=getToolByName(self,'acl_users')
        groups=self._stringToList(groups) #clean out the empty ones
        
        if not hasattr(acl_users,'getGroupPrefix'):
            return # do nothing if GRUF is not installed

        pref=acl_users.getGroupPrefix()
        
        roles=tuple([r for r in self.getRoles() if not r.startswith(pref) ])+tuple([pref+g for g in groups])
        self.setSecurityProfile(roles=roles)
        self.getUser()
        
        
    def getGroups(self):
        ''' fetches the groups from GRUF '''
        acl_users=getToolByName(self,'acl_users')
        
        user=self.getUser()
        
        if not hasattr(user,'getGroups'): #return empty list if user comes another acl_user
            return []
        
        groups=user.getGroups()
        try:
            res = [g.getUserNameWithoutGroupPrefix() for g in groups if g.getUserNameWithoutGroupPrefix()]
        except AttributeError:
            # then the groups come as array of strings
            pref=acl_users.getGroupPrefix()
            res = [g[len(pref):] for g in groups if g != pref]
            
        return res

    
    def getRawGroups(self):
        '''fetches the Group names from GRUF with prefix '''
        user=self.getUser()
        if not hasattr(user,'getGroups'): #return empty list if user comes another acl_user
            return []

        acl_users=getToolByName(self,'acl_users')
        pref=acl_users.getGroupPrefix()
        
        groups=user.getGroups()
        try:
            res = [g.getId() for g in groups if g.getId() != pref]
        except AttributeError:
            res = [g for g in groups if g != pref]
        return res
        
    def valid_groups(self):
        acl_users=getToolByName(self,'acl_users')
        if not hasattr(acl_users,'getGroups'):
            return []
        groups=acl_users.getGroups()
        res = [g.id for g in groups if g.id]
        return res
    
    
    
    # ########################################################################
    # Validators and vocabulary methods

    security.declarePrivate('validate_id')
    def validate_id(self, id):
        # no change -- ignore
        if self.id and (not id or id == self.id):
            return None

        memberdata_tool = getToolByName(self, 'portal_memberdata')
        if memberdata_tool.get(id, None):
            return 'This name is already in use.  Please choose another.'
        
        registration_tool = getToolByName(self, 'portal_registration')
        if registration_tool.isMemberIdAllowed(id):
            return None
        else:
            return 'Names can only include letters and numbers.  Please choose another.'

    
    security.declarePrivate('validate_password')
    def validate_password(self, password):
        # no change -- ignore
        if not password:
            return None

        registration_tool = getToolByName(self, 'portal_registration')
        return registration_tool.testPasswordValidity(password)


    security.declarePrivate('validate_roles')
    def validate_roles(self, roles):
        roles = self._stringToList(roles)
        valid = self.valid_roles() + ('Authenticated',) + tuple(self.getRawGroups())
        
        for r in roles:
            if r not in valid:
                return '%s is not a valid role.' % (r)
        return None


    security.declarePrivate('post_validate')
    def post_validate(self, REQUEST, errors):
        if REQUEST and not(errors.get('password', None)) and not(errors.get('confirm_password', None)):
            if REQUEST.get('password', None) != REQUEST.get('confirm_password', None):
                errors['password'] = errors['confirm_password'] = \
                    'Your password and confirmation did not match. ' \
                     + 'Please try again.'


    security.declarePublic('isValid')
    def isValid(self):
        """ Check to make sure a Member object's fields satisfy schema constraints"""
        errors = {}
        # make sure object has required data and metadata
        self.Schema().validate(self, None, errors, 1, 1)
        if errors:
#            import sys
#            sys.stdout.write('isValid, errors = %s\n' % (str(errors)))
            return 0
        return 1


    # Vocabulary methods
    def editors(self):
        return self.portal_properties.site_properties.available_editors


    def valid_roles(self):
        return self.getUser().valid_roles()


    def available_skins(self):
        # give managers the ability to choose any skin
        managePortal = getToolByName(self, 'portal_membership').checkPermission(CMFCorePermissions.ManagePortal, self)
        skins_tool = getToolByName(self, 'portal_skins')
        if skins_tool.getAllowAny() or managePortal:
            return getToolByName(self, 'portal_skins').getSkinSelections()
        else:
            return [self.getPortalSkin()]


    def getDefaultSkin(self):
        return getToolByName(self, 'portal_skins').getDefaultSkin()
    
    # ########################################################################
    # Contract with portal_membership

    security.declarePublic('getMemberId')
    def getMemberId(self):
        """Get the member id """
        return self.getUserName()

    
    security.declareProtected(EDIT_PROPERTIES_PERMISSION, 'setProperties')
    def setProperties(self, mapping=None, **kwargs):
        """assign all the props to member attributes, we expect
        to be able to find a mutator for each of these props
        """
        #We know this is an Archetypes based object so we look for
        #mutators there first

        # if mapping is not a dict, assume it is REQUEST
        if mapping:
            if not type(mapping) == type({}):
                data = {}
                for k,v in mapping.form.items():
                    data[k] = v
                mapping = data
        else:
            mapping = {}

        if kwargs:
            # mapping could be a request object thats not really a dict,
            # this is what we get
            mapping.update(kwargs)

        self.update(**mapping)

        # XXX - there has to be a better way!!
        if mapping.has_key('login_time'):
            self.login_time = mapping['login_time']
        if mapping.has_key('last_login_time'):
            self.last_login_time = mapping['last_login_time']


    security.declarePrivate('setMemberProperties')
    def setMemberProperties(self, mapping):
        self.setProperties(mapping)


    def _getProperty(self, id):
        """Try to get a member property.  If the property is not found,
        raise an AttributeError"""
        field = self.Schema().get(id, None)
        if field is not None:
            accessor = getattr(self, field.accessor, None)
            value = accessor()
        else:
            base = aq_base(self)
            value = getattr(base, id)
        return value


    security.declarePublic('getProperty')
    def getProperty(self, id, default=_marker):
        try:
            return self._getProperty(id)
        except AttributeError:

            # member does not have a value for given property
            # try memberdata_tool for default value
            memberdata_tool = getToolByName(self, 'portal_memberdata')
            tool_value = memberdata_tool.getProperty(id, _marker)
            user_value = getattr(self.getUser(), id, _marker)

            # If the tool doesn't have the property, use user_value or default
            if tool_value is _marker:
                if user_value is not _marker:
                    return user_value
                elif default is not _marker:
                    return default
                else:
                    raise ValueError, 'The property %s does not exist' % id
    
            # If the tool has an empty property and we have a user_value, use it
            if not tool_value and user_value is not _marker:
                return user_value
    
            # Otherwise return the tool value
            return tool_value

    def isListed(self):
        # XXX this is rather inflexible...
        roles = rolesForPermissionOn('View', self)
        if 'member' in roles:
            return 'Yes'
        else:
            return 'No'


# ##############################################################################
# Methods for managing the user object associated with this member
#
# Member objects are associated with a user.  However, not all Member objects
# have a real user in acl_users -- the real user in an acl_users folder is only 
# created upon registration.
#
# * For Members who do have a real associated User object in an acl_users folder
# somewhere, we cache the associated User in a volatile variable in the Member
# object.  The path to the associated user is stored in self._userInfo as a 
# 2-tuple consisting of a path to the acl_users folder and the id of the user.
# The method _getUserFromInfo converts this user info into a real user that is
# cached in self._v_user when getUser() is first called after the object is 
# awakened from the ZODB.
#
# * For Members who do not yet have associated acl_users user objects, we 
# create a temporary placeholder user # object that is stored in self._v_user
# (this seemed like a good idea at the time -- I'm not sure this is the right 
# way to do this).
#
# self._v_user The representation is a 1-tuple containing the cached user (the
#   tuple is a hack to preserve the acquisition context)
# 
# self._userInfo stores the path to the acl_users containing the user object
#   and the user id IF a real user exists in an acl_users folder.  If no real
#   user object exists, self._userInfo is None

    security.declarePublic('getUser')
    def getUser(self):
        """Return the user object associated with the member"""
        if self._userInfo is None:
            self._createTempUser()
        elif not hasattr(self, '_v_user') or self._v_user is None:
            self._v_user = (self._getUserFromInfo(self._userInfo),)
            if self._v_user[0] is None:
                # orphan! -- our associated user object has been deleted
                self._createTempUser()

        try:
            self._v_user[0]
        except:
            import pdb
            pdb.set_trace()
        return self._v_user[0]


    security.declarePrivate('setUser')
    def setUser(self, user):
        """Set the Member's user object"""
        # make sure the user is wrapped with an acquisition context
        base = getattr(user, 'aq_base', None)
        if base is None:
            # look up the user by id
            u = self._getUserById(user.getUserName())
            if u:
                # wrapped user found
                user = u
            else:
                # user not found -- wrap it in portal.acl_users
                user = user.__of__(getToolByName(self, 'portal_url').getPortalObject().acl_users)
        user = aq_inner(user) # get portal_membership, etc out of the aquisition chain
        acl_users = aq_parent(user)

        self._userInfo = self._getInfoFromUser(user)
        assert self._userInfo != []
        assert(user.getUserName() == self.id)
        self._v_user = (user,)

        if hasattr(user, '_getPassword'):
            # for GRUF
            self.password = user._getPassword()
            self.roles = user.getRoles()
            self.domains = user.getDomains()
        else:
            # for ordinary acl_users
            self.password = user.__
            self.roles = user.roles
            self.domains = user.domains


    def hasUser(self):
        """Returns 1 if there is a real acl_users user associated with this
        Member, 0 if a temporary internal one."""
        return self._userInfo is not None


    def isOrphan(self):
        if self._userInfo:
            if self._getUserFromInfo(self._userInfo) is None:
                return 1
        return 0


    def _createUser(self):
        """Create a real user for this member in the portal's acl_users folder"""
        acl_users = getToolByName(self, 'portal_url').getPortalObject().acl_users
        acl_users.userFolderAddUser(self.id, self.password, self.roles, self.domains)
        user = acl_users.getUser(self.id).__of__(acl_users)
        self._userInfo = self._getInfoFromUser(user)
        self._v_user = (user,)


    def _createTempUser(self):
        """Create a temporary placeholder user for this member to use for
        delegation until a real acl_users user is created"""
        acl_users = getToolByName(self, 'portal_url').getPortalObject().acl_users
        self._v_user = (User.SimpleUser(self.id, self.password, self.roles, self.domains).__of__(acl_users),)


    def _getInfoFromUser(self, user):
        """Convert a user to a tuple consisting of a path string + a user id.  
        If the user's acl_users folder is outside the portal, generate an 
        absolute path starting with a '/' starting from the zope root.  If the 
        acl_users folder is in the portal, generate a path not starting with a 
        '/' that is relative to the portal root."""
        if user is None:
            return None
        acl_users = aq_parent(aq_inner(user))
        path = '/'.join(acl_users.getPhysicalPath())
        portal_path = '/'.join(getToolByName(self, 'portal_url').getPortalObject().getPhysicalPath())+'/'
        if path.startswith(portal_path):
           path = path[len(portal_path):]
        return (path, user.getUserName())


    def _getUserFromInfo(self, info):
        """Convert a user info tuple into a wrapped user."""
        if info is None:
            return None
        path, id = info
        portal = getToolByName(self, 'portal_url').getPortalObject()
        acl_users = portal.unrestrictedTraverse(path)
        user = acl_users.getUser(id)
        if user is None:
                # temp fix:
                # when reimporting a  plone portal with
                # CMFMember it breaks on catalog indexing
                # because the posrtal_memberdata gets 
                # imported before acl_users
                # XXX: find a solution to force acl_users to
                # be imported before CMFMember stuff
            return user
        return user.__of__(acl_users)
        # XXX should context be self.acl_users or self._user's original context?
        # return aq_base(self._user).__of__(self.acl_users)


    def _isPortalUser(self, user):
        """Test whether a user object comes from the portal's acl_users folder"""
        if not self._userInfo:
            return 0
        return self._userInfo[0] == 'acl_users'
        

    def _updateCredentials(self):
        if self.REQUEST:
            # don't log out the current user
            assert self.hasUser()
            user = self.getUser()
            acl_users = aq_parent(user)
            if hasattr(aq_base(acl_users), 'credentialsChanged'):
                # Use an interface provided by LoginManager.
                acl_users.credentialsChanged(user, self.getId(), self.getPassword())
            else:
                p = getattr(self.REQUEST, '_credentials_changed_path', None)
                if p is not None:
                    # Use an interface provided by CookieCrumbler.
                    change = self.restrictedTraverse(p)
                    change(user, self.getId(), self.getPassword())


    def _getUserFolderForUser(self, id=None):
        f = getToolByName(self, 'portal_url').getPortalObject()
        if id is None:
            return f.acl_users
        while 1:
            if not hasattr(f, 'objectIds'):
                return
            if 'acl_users' in f.objectIds():
                if hasattr(f.acl_users, 'getUser'):
                    user = f.acl_users.getUser(id)
                    if user is not None:
                        return f.acl_users
            if hasattr(f, 'getParentNode'):
                f = f.getParentNode()
            else:
                return None


    def _getUserById(self, id):
        """A utility method for finding a user by searching through
        portal.acl_users as well as the acl_users folders for all
        zope folders containing portal.
        
        Returns the user in the acquisition context of its containing folder"""
        acl_users = self._getUserFolderForUser(id)
        if acl_users is None:
            return None
        return acl_users.getUser(id).__of__(acl_users)


    def _changeUserInfo(self, move, old_user, new_user=None):
        """A utility method for transferring/deleting local roles and ownership 
        when a member is copied, renamed, or deleted.
        
        If move = 0, local roles are copied from old_user to new_user and
        ownership remains the same.
        
        If move = 1, local roles are moved from old_user to new_user.
        If new_user is None, old_user's local roles are simply removed.  
        Ownership is transferred from old_user to new_user.  If new_user is
        None, objects owned by old_user are deleted."""

        old_user_id = old_user.getUserName()

        if new_user:
            new_user_id = new_user.getUserName()
        else:
            new_user_id = None

        catalog = getToolByName(self, 'portal_catalog')

        localRoleObjects = catalog.search({'indexedUsersWithLocalRoles':old_user.getUserName()})
        
        reindex = []
        
        for o in localRoleObjects:
            object = o.getObject()
            if object is not None and object != self:
                if new_user_id:
                    # copy local roles for old user to local roles for new user
                    roles = object.get_local_roles_for_userid(old_user_id)
                    if roles:
                        object.manage_addLocalRoles(new_user_id, roles)
                        reindex.append(object)
                if move:
                    # remove local roles for old user
                    object.manage_delLocalRoles([old_user_id])

        if move:
            old_user_path = '/'.join(aq_parent(aq_inner(old_user)).getPhysicalPath())+'/'+old_user_id
            ownedObjects = catalog.search({'indexedOwner':old_user_path})
 
            for o in ownedObjects:
                object = o.getObject()
                if object is not None and object != self:
                    if self.handleOrphanedContent(object, new_user):
                        reindex.append(object)

        for o in reindex:
            o.reindexObject()

    # ########################################################################
    # Overrides of base class mutators that trigger workflow transitions
    
    def update(self, **kwargs):
        membership_tool = getToolByName(self, 'portal_membership')
        updateSelf = membership_tool.getAuthenticatedMember().getUserName() == self.getUserName()
        ret = BaseContent.update(self, **kwargs)
        if updateSelf:
            self._updateCredentials()
        # invoke any automated workflow transitions after update
        triggerAutomaticTransitions(self)
        return ret


    def processForm(self, data=1, metadata=0):
        membership_tool = getToolByName(self, 'portal_membership')
        updateSelf = membership_tool.getAuthenticatedMember().getUserName() == self.getUserName()
        ret = BaseContent.processForm(self, data, metadata)
        if updateSelf:
            self._updateCredentials()
        # invoke any automated workflow transitions after update
        triggerAutomaticTransitions(self)
        return ret


    # ########################################################################
    # Methods triggered by workflow transitions

    security.declarePrivate('register')
    def register(self, auto=0):
        try:
            registration_tool = getToolByName(self, 'portal_registration')
            email_notify = 0
            # create a real user
            if not self.hasUser():
                # Limit the granted roles.
                # Anyone is always allowed to grant the 'Member' role.
                roles = self.getFilteredRoles()
                _limitGrantedRoles(roles, self, ('Member',))
                self.setRoles(roles)
                self._createUser()
                # only send mail if we had to create a new user -- this avoids
                # sending mail to users who are already registered at the Zope root level
                email_notify = 1
    
            # make the user the owner of the current member object
            self.changeOwnership(self.getUser(), 1)
            self.manage_setLocalRoles(self.getUserName(), ['Owner'])
            # XXX - should we invoke this for members with users in the Zope root acl_user?
            try:
                registration_tool.afterAdd(self, self.getUserName(), self.getPassword(), None)
            except ConflictError:
                raise
            except:
                logException()
            self.updateListed()
            self._changeFieldsAfterRegistration()

            if email_notify and auto:
                # check to see if 'mail_me' was set for auto-registration
                if not self['mail_me']:
                    email_notify = 0

            if email_notify:
                registration_tool.registeredNotify(self.getUserName())
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise

    def _changeFieldsAfterRegistration(self):
        """
        Fix up fields that need different settings after
        registration.
        """
        fldchg = (('id', {'required':0}),
                  ('password', {'required':0}),
                  ('confirm_password', {'required':0}),
                 )
        schema = self.getSchema()
        for fieldname, params in fldchg:
            field = schema.get(fieldname, None)
            if field:
                for key, value in params.items():
                    setattr(field, key, value)
    
    security.declarePrivate('autoRegister')
    def autoRegister(self):
        self.register(auto=1)

    security.declarePrivate('disable')
    def disable(self):
        try:
            self._setPassword(self._generatePassword())
            workflow_tool = getToolByName(self, 'portal_workflow')
            self.old_state = workflow_tool.getInfoFor(self, 'review_state', '')
            self.updateListed()
        except:
             # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('enable')
    def enable(self):
        try:
            if hasattr(self, 'old_state'):
                delattr(self, 'old_state')
            self.updateListed()
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('makePublic')
    def makePublic(self):
        try:
            self.updateListed()
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('makePrivate')
    def makePrivate(self):
        try:
            self.updateListed()
        except:
            # write tracebacks because otherwise workflow will swallow exceptions
            logException()
            raise


    security.declarePrivate('updateListed')
    def updateListed(self):
        """Extract the correct value of the Member's 'listed' attribute from
           current security settings."""
        membership_tool = getToolByName(self, 'portal_membership')
        self.listed = membership_tool.checkPermission(VIEW_PUBLIC_PERMISSION, self)
        

    # ########################################################################
    # Methods for dealing with copy / rename / delete

    security.declareProtected(EDIT_ID_PERMISSION, 'setId')
    def setId(self, id):
        if not id:
            id = self.getId()
        memberdata=getToolByName(self, 'portal_memberdata')
        memberdata.manage_renameObjects( (self.getId(),), (id,) )


    def _notifyOfCopyTo(self, container, op=0):
        try:
            Member.inheritedAttribute('_notifyOfCopyTo')(self, container, op)
            if op:
                self._v_old_user = [self.getUser()] # get user with aq context, store in a list to keep from stomping wrapper
        except:
            logException()
            raise


    security.declarePrivate('manage_afterAdd')
    def manage_afterAdd(self, object, container):
        try:
            BaseContent.manage_afterAdd(self, object, container)

            if hasattr(object, '_migrating'):
                return
            
            old_user = getattr(object, '_v_old_user', None)
            if old_user:
                delattr(object, '_v_old_user')
                old_user = old_user[0]

                if old_user and object.id == old_user.getUserName():
                    return

                # object has been renamed
                if object.hasUser():
                    # The old member had a real user, so we need to 
                    # create a real user for the new member and transfer
                    # ownership and local roles to the new member's user
                    object._createUser()
                    portal = getToolByName(self, 'portal_url').getPortalObject()
                    # change local roles and content ownership info
                    new_user = object.getUser()
                    object._changeUserInfo(1, old_user, new_user)

                    # make the user the owner of the current member object
                    object.manage_delLocalRoles([old_user.getUserName()])
                    object.changeOwnership(new_user, 1)
                    object.manage_setLocalRoles(object.getUserName(), ['Owner'])

                    # Delete the old user object if it was from portal.acl_users but not
                    # if it was from zope_root.acl_users.
                    if object._isPortalUser(old_user):
                        # delete the old user
                        if portal.acl_users.getUser(old_user.getUserName()):
                            portal.acl_users.userFolderDelUsers([old_user.getUserName()])
        except:
            logException()
            raise


    security.declarePrivate('manage_afterClone')
    def manage_afterClone(self, object):
        try:
            if self.hasUser():
                old_user = self.getUser()
                # the copied member had a real user -- create a real user for the copy
                self._createUser()
                new_user = self.getUser()

                portal = getToolByName(self, 'portal_url').getPortalObject()
                self._changeUserInfo(0, old_user, new_user)
                
                # make the user the owner of the current member object
                roles = list(self.get_local_roles_for_userid(old_user.getUserName()))
                if 'Owner' in roles:
                    roles.remove('Owner')
                    if roles:
                        self.manage_setLocalRoles(old_user.getUserName(), roles)
                    else:
                        self.manage_delLocalRoles([old_user.getUserName()])
                self.changeOwnership(self.getUser(), 1)
                self.manage_setLocalRoles(self.getUserName(), ['Owner'])
        except:
            logException()
            raise


    security.declarePrivate('manage_beforeDelete')
    def manage_beforeDelete(self, item, container):
        try:
            if hasattr(self, '_v_old_user'):
                # if we are in the midst of a move, do nothing
                return

            if hasattr(self, '_migrating'):
                # if we are in the midst of a migration, do nothing
                return

            # XXX FIXME this is a hack
            # Here's what this addresses (I think): when a site is deleted,
            # acl_users may be deleted before portal_memberdata.  The member
            # object in portal_memberdata holds a reference to the user object
            # in acl_users.  When acl_users gets deleted, the user object
            # remains because its refcount is > 0, but it is now unwrapped.
            # At this point we should just bail.
            if self.getUser() == None:
                self._v_user = None # remove references to user
                return

            portal = getToolByName(self, 'portal_url').getPortalObject()

            # make sure user comes from the portal.acl_users folder and not
            # zope.acl_users or somewhere above the portal
            if self._isPortalUser(self.getUser()): 
                # recurse through the portal and delete all of the user's content
                # XXX we should create some other options here
                self._changeUserInfo(1, self.getUser(), None)
                # Delete the User object if it's in the current portal's acl_users folder.
                if portal.acl_users.getUser(self.id):
                    portal.acl_users.userFolderDelUsers([self.id])
            self._v_user = None # remove references to user
            BaseContent.manage_beforeDelete(self, item, container)
        except:
            logException()
            raise


    # ########################################################################
    def _generatePassword(self):
        try:
            registration_tool = getToolByName(self, 'portal_registration')
            return registration_tool.generatePassword()
        except AttributeError:

            try:
                password = ''
                n = len(RegistrationTool.password_chars)
                for i in range(0,6):
                    password += RegistrationTool.password_chars[random.randint(0,n-1)]
                return password
            except:
                logException()
                raise

    # replacement for portal_registration's mailPassword function
    security.declareProtected(MAIL_PASSWORD_PERMISSION, 'mailPassword')
    def mailPassword(self):
        """ Email a forgotten password to a member."""
        # assert that we can actually get an email address, otherwise
        # the template will be made with a blank To:, this is bad
        if not self.getProperty('email'):
            raise 'ValueError', 'Member does not have an email address.'

        password = self.getPassword()        
        # Rather than have the template try to use the mailhost, we will
        # render the message ourselves and send it from here (where we
        # don't need to worry about 'UseMailHost' permissions).
        mail_text = self.mail_password_template( self
                                               , self.REQUEST
                                               , member=self
                                               , password=password
                                               )
        host = self.MailHost
        host.send( mail_text )
        return self.mail_password_response( self, self.REQUEST )


    # ########################################################################
    # utility methods

    def _stringToList(self, s):
        if s is None:
            return []
        if isinstance(s, types.StringType):
            # split on , or \n and ignore \r
            s = s.replace('\r',',')
            s = s.replace('\n',',')
            s = s.split(',')
        s= [v.strip() for v in s if v.strip()]
        s = filter(None, s)
        return [o for o in s if o]


    # XXX REFACTOR ME
    # This is used for a hack in MemberDataContainer
    def _getTypeName(self):
        return 'CMFMember Content'


    # ########################################################################
    # Migration methods.  Used to migrate CMFCore member data to Member
    # objects or to migrate from from one type of member objects to another.
        
    def _migrate(self, old_member, excluded_fields, out):
        """Set Member attributes using values from old_member"""

        if type(old_member) == type({}):
            properties = old_member['properties']
            fields = self.Schema().fields() + ['listed', 'login_time', 'last_login_time']
            for new_field in fields:
                if type(new_field) != type(''):
                    name = new_field.getName()
                if name not in ['id', 'password', 'roles', 'domains'] and \
                   name not in excluded_fields: # fields managed by user object
                    try:
                        value = properties.get(name)
                        self._migrateSetNewValue(name, value, out)
                        out.append('%s.%s = %s' % (old_member['user'].getUserName(), name, str(value)))
                    except:
                        out.append('Unable to get field %s from member %s' % (name, old_member['user'].getUserName()))
                self.setId(old_member['user'].getUserName())

            self.portrait = old_member['portrait']
            self.setUser(old_member['user'])

        else:
            fields = self.Schema().fields() + ['listed', 'login_time', 'last_login_time']
            for new_field in fields:
                if type(new_field) != type(''):
                    name = new_field.getName()
                if name not in ['password', 'roles', 'domains'] and \
                   name not in excluded_fields: # fields managed by user object
                    try:
                        value = self._migrateGetOldValue(old_member, name, out)
                        self._migrateSetNewValue(name, value, out)
                        out.append('%s.%s = %s' % (str(old_member.getMemberId()), name, str(value)))
                    except:
                        out.append('Unable to get field %s from member %s' % (name, old_member.getUserName()))
                        pass

            # move the user over
            self.setUser(old_member.getUser())

    def _migrateGetOldValue(self, old, id, out):
        """Try to get a value from an old member object using a variety of
        methods."""
        old_schema = getattr(old, 'Schema', None)
        if old_schema is not None:
            old_schema = old_schema()

        new_schema = self.Schema()

        if old_schema:
            old_field = old_schema.get(id, None)
            if old_field:
                accessor = getattr(old, old_field.accessor, None)
                if accessor is not None:
                    return accessor()
        new_field = new_schema.get(id)
        accessor = getattr(old, new_field.accessor, None)
        if callable(accessor):
            try:
                return accessor()
            except:
                pass

        if hasattr(old, id):
            return getattr(old, id)
        
        out.append('Unable to get property %s from member %s\n' % (new_field.name, old.getMemberId()))
        raise ValueError
    
        
    def _migrateSetNewValue(self, id, value, out):
        """Utility method for setting a Member attribute using a variety of methods"""
        new_schema = self.Schema()
        new_field = new_schema.get(id, None)
        if new_field:
            if new_field.mutator is not None:
                mutator = getattr(self, new_field.mutator)
                mutator(value)
                return
            if hasattr(self, id):
                setattr(self, id, value)
                return
            out.append('Unable to set property %s from member %s\n' % (new_field.name, self.getMemberId()))
            raise ValueError
        else:
            if hasattr(self, id):
                setattr(self, id, value)
                return
            out.append('Unable to set property %s from member %s\n' % (id, self.getMemberId()))
            raise ValueError

    
    def getSchema(self):
        md_tool = getToolByName(self, 'portal_memberdata')
        return md_tool.getMemberSchema()    
   
registerType(Member)
